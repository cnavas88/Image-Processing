class get_mouse_click():
    
    #Mouse interaction interface for radial distortion removal.
    def __init__(self, img):
      height, width = img.shape[:2]
      self.figure = plt.imshow(img, extent=(0, width, height, 0))
      plt.gray()
      plt.title('select the object to remove')
      plt.xlabel('Select sets of  points with left mouse button,\n'
                 'click right button to close the polygon.')
      plt.connect('button_press_event', self.button_press)
      plt.connect('motion_notify_event', self.mouse_move)

      self.img = np.atleast_3d(img)
      self.points = []
      self.centre = np.array([(width - 1)/2., (height - 1)/2.])

      self.height = height
      self.width = width

      self.make_cursorline()
      self.figure.axes.set_autoscale_on(False)

      plt.show()
      plt.close()

    def make_cursorline(self):
        self.cursorline, = plt.plot([0],[0],'r:+', linewidth=2,markersize=15,markeredgecolor='b')

    def button_press(self,event):
        # Register mouse clicks.
        if (event.button == 1 and event.xdata and event.ydata):
            self.points.append((event.xdata,event.ydata))
            plt.gca().lines.append(self.cursorline)
            plt.gca()
            self.make_cursorline()
        if (event.button != 1):
            self.points.append((self.points[0][0],self.points[0][1]))
            plt.close()
            return self.points

    def mouse_move(self,event):
        # Handle cursor drawing.
        pts_last_set=len(self.points)
        pts = np.zeros((pts_last_set+1,2))
        if pts_last_set > 0:
            # Line follows up to 3 clicked points:
            pts[:pts_last_set] = self.points[-pts_last_set:]
            # The last point of the line follows the mouse cursor
        pts[pts_last_set:] = [event.xdata,event.ydata]
        self.cursorline.set_data(pts[:,0], pts[:,1])
        plt.draw()
def compute_mask(width,height,polygon):
    
    img = Image.new('L', (width, height), 0)
    ImageDraw.Draw(img).polygon(polygon, outline=1, fill=1)
    mask = np.array(img)
    #mask100 = 100*np.ones([mask.shape[0],mask.shape[1]])
    #mask=mask*101
    #mask = 1. - mask; # switch 0s and 1s
    return mask
def convine_mask(zona_delete,img_gris):
    #si tenim 1 a la macara tenim forat
    for i in xrange(len(img_gris)):
        for j in xrange(len(img_gris[0])):
            if zona_delete[i][j]==1:
                img_gris[i][j]=-100
    return img_gris
def buscar_pix(img,t,r,finestra):   
    for i in xrange(len(img)):
        for j in xrange(len(img[0])):
            
            if img[i][j]!=-100:
                #if img[i][j]-img[t][r]<=0.1 and grad[i][j]-grad[t][r]<=0.1:
                if img[i][j]-img[t][r]<=0.8:
                    pix=(img[i][j]+img[i-1][j-1]+img[i-1][j]+img[i][j-1])/4
                    #print "t,r",img_mask[t][r]
                    #print "i,j",img_mask[i][j]
                    return pix
def reccorrer_img(finestra,finestra_validar,img_gris,t,r):
    dif=0.
    for i in xrange(len(img_gris)-8):
        for j in xrange(len(img_gris[0])-8):
            valors = millors_pix(finestra,finestra_validar,img_gris,i,j)
            
            #si la puntuació es inferior al valor es que es prou semblant
            if valors >=dif:
                if valors==0:
                    print i,j
                    return i,j,img_gris[i][j]
                else:
                    
                    dif=valors
                    valor=i,j,img_gris[i][j]

    return i,j,img_gris[i][j]
def millors_pix(finestra,finestra_validar,img_gris,t,r):
    #print finestra.shape
    #print finestra_validar.shape
    total_ones_mask = finestra_validar.sum()
    #aqui fariem el calcul de la formula explicada pel professor
    #1/numero de 1 de la mascara*(Ixy-Fxy)² ssd = float(np.sum((img_gris[:,:,0:3] - finestra[:,:,0:3])**2))
    for i in xrange(len(finestra_validar)):
        for j in xrange(len(finestra_validar[0])):
            ssd = float(np.sum(finestra_validar[i][j]*(img_gris[t+i,r+i] - finestra[i][j])**2))

    #print finestra_validar
    #print (1./total_ones_mask)*ssd
    return (1./total_ones_mask)*ssd
























rdi = get_mouse_click(img_gris.astype('uint8'))
height,width=img_gris.shape
zona_delete = compute_mask(width,height,rdi.points)
##################3faltaria el tema que va comentar d'usuar una imatge copia xk no afectes.
#####################per altra part a la herba no funciona i s'ha de fer que pari quan ja no tingi mascara
#calculo el primer contorn a substituir restant la mascara menys ella mateixa erosionada
cont=0
for p in xrange(5):
    zona_delete_erosio=ndimage.binary_erosion(zona_delete)
    #busco el contorn mes extern de la part a substituir
    delete_ceva =zona_delete - zona_delete_erosio 
    #actualitzo la mascara amb el que ja haurem substituit
    zona_delete = zona_delete_erosio
    finestra = np.zeros((8,8))
    finestra_validar = np.ones((8,8), dtype=np.int)
    img_gris_convine=convine_mask(zona_delete,img_gris)
    for i in xrange(len(delete_ceva)):
        for j in xrange(len(delete_ceva[0])):
            if delete_ceva[i][j]==1:
                #print i,j
                finestra=zona_delete[i-4:i+4,j-4:j+4]
                #finestra2 per multiplicar on tenim 0 on hi haura el forat
                finestra_validar=abs(finestra-finestra_validar)
                #finestra_retorna=funcio que retornara la finestra mes similar
                t,r,de=reccorrer_img(finestra,finestra_validar,img_gris_convine,i,j)
                print img_gris[t][r]
                img_gris[i][j]=img_gris[t][r]
                misc.imsave('imatges/'+str(cont+1)+'.png',img_gris)
                cont= cont +1
                #fig = plt.figure(123) 
                #plt.imshow(img_gris)
                #plt.title('Contorn')
                #plt.show()
